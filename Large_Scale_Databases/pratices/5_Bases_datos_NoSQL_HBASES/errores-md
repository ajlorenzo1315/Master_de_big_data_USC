java -jar  target/HBaseTest-1.0-SNAPSHOT.jar                                                                                                                       
no hay ningún atributo de manifiesto principal en target/HBaseTest-1.0-SNAPSHOT.jar 

solurtion

cambiar pomx.xml

<build>
    <plugins>
        <!-- Otros plugins -->

        <!-- Configuración del maven-jar-plugin -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>3.2.0</version> <!-- Asegúrate de usar una versión adecuada -->
            <configuration>
                <archive>
                    <manifest>
                        <addClasspath>true</addClasspath>
                        <mainClass>gal.usc.etse.mbd.bdge.hbasetest.test1</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>



# error


java -jar  target/HBaseTest-1.0-SNAPSHOT.jar
Error conectando a la base de datos postgesql:No suitable driver found for jdbc:postgresql://localhost:5432/bdge
Exception in thread "main" java.lang.NullPointerException
        at gal.usc.etse.mbd.bdge.hbasetest.DAOPeliculasPgsql.getPeliculas(DAOPeliculasPgsql.java:132)
        at gal.usc.etse.mbd.bdge.hbasetest.test1.testInsercionHBase(test1.java:33)
        at gal.usc.etse.mbd.bdge.hbasetest.test1.main(test1.java:17)

# solucion

El error que estás experimentando indica dos problemas principales:

    Error de Conexión con PostgreSQL: Error conectando a la base de datos postgresql:No suitable driver found for jdbc:postgresql://localhost:5432/bdge. Este error significa que la aplicación no pudo encontrar el controlador JDBC para PostgreSQL, que es necesario para establecer la conexión con tu base de datos PostgreSQL.

    NullPointerException: Este error ocurre en tu clase DAOPeliculasPgsql, lo que indica que estás intentando utilizar una referencia que no ha sido inicializada.

Solucionando el Problema con el Controlador JDBC de PostgreSQL

Para solucionar el primer problema, asegúrate de lo siguiente:

    Dependencia en el pom.xml: Verifica que tienes la dependencia correcta de PostgreSQL en tu archivo pom.xml. La dependencia debería verse así:

    xml

<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.23</version>
</dependency>

Paquete del JAR con Dependencias: Asegúrate de que estás empaquetando todas las dependencias necesarias dentro de tu archivo JAR. Esto se puede hacer con el uso del plugin maven-assembly-plugin o maven-shade-plugin en tu pom.xml. Estos plugins incluyen todas las dependencias en tu archivo JAR final.


Solucionando el NullPointerException

Para el NullPointerException, necesitarás revisar tu código en DAOPeliculasPgsql.java y test1.java.

    Revisa la Conexión a la Base de Datos: Asegúrate de que estás estableciendo correctamente la conexión a la base de datos antes de intentar realizar operaciones en ella. El NullPointerException puede ocurrir si intentas acceder a una conexión que no se ha establecido.

    Revisa la Inicialización de Objetos: Asegúrate de que todos los objetos que estás utilizando en tus métodos han sido inicializados correctamente antes de usarlos.

    Manejo de Excepciones: Implementa un manejo adecuado de excepciones para capturar y manejar posibles errores de forma más informativa. Esto te ayudará a identificar y solucionar problemas en el futuro.

Pasos Adicionales

    Revisar la Configuración de la Base de Datos: Asegúrate de que tu base de datos PostgreSQL esté corriendo y que los detalles de conexión (URL, puerto, nombre de la base de datos, usuario, contraseña) sean correctos.
    Controlador JDBC en el Classpath: Si estás ejecutando tu aplicación fuera de un entorno Maven (como un archivo JAR independiente), necesitas asegurarte de que el controlador JDBC esté incluido en el classpath.
    Depuración: Considera agregar más registros (logging) a tu código para obtener información detallada sobre el flujo de ejecución y los posibles puntos de fallo.

Si puedes proporcionar más detalles sobre tu configuración o los extractos de código relevantes, podría darte consejos más específicos sobre cómo abordar estos problemas.


### cambiar version de java

sudo apt-get install openjdk-8-jdk




/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package gal.usc.etse.mbd.bdge.hbasetest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.CompareOperator;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Admin;
import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.ConnectionFactory;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.ResultScanner;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;
import org.apache.hadoop.hbase.util.Bytes;

/**
 *
 * @author alumnogreibd
 */
public class DAOPeliculasHBase implements DAOPeliculas {
    Connection con;
    
    public DAOPeliculasHBase(){
        try {
            Configuration conf = HBaseConfiguration.create();
            this.con = ConnectionFactory.createConnection(conf);
        } catch (IOException ex) {
            System.out.print("Error conectando con HBase: "+ex.getMessage()+"\n");
        }
    }
    
    public void close(){
        try {
            con.close();
        } catch (IOException ex) {
            System.out.print("Error cerrando conexión con HBase: "+ex.getMessage()+"\n");
        }
    }

    @Override
    public List<Pelicula> getPeliculas(int num) {
        List<Pelicula> resultado = new ArrayList<Pelicula>();
        try {
            Scan scan = new Scan();
            scan.addFamily(Bytes.toBytes("info"));
            scan.addFamily(Bytes.toBytes("reparto"));
            scan.addFamily(Bytes.toBytes("personal"));
            scan.setLimit(num);
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));
            ResultScanner rs = pelsTable.getScanner(scan);
            try {
            for (Result filaPelicula = rs.next(); filaPelicula != null; filaPelicula = rs.next()) {
               NavigableMap mapReparto=filaPelicula.getFamilyMap(Bytes.toBytes("reparto"));
               Reparto[] reparto = new Reparto[mapReparto.size()];
               int i=0;
               for (Map.Entry<byte[], byte[]> elemReparto: (Set<Map.Entry>) mapReparto.entrySet()){
                 reparto[i]=(Reparto) Utils.deserialize(elemReparto.getValue());
                 i++;
               }
               NavigableMap mapPersonal=filaPelicula.getFamilyMap(Bytes.toBytes("personal"));
               Personal[] personal = new Personal[mapPersonal.size()];
               i=0;
               for (Map.Entry<byte[], byte[]> elemPersonal: (Set<Map.Entry>) mapPersonal.entrySet()){
                 personal[i]=(Personal) Utils.deserialize(elemPersonal.getValue());
                 i++;
               }
               NavigableMap mapInfo = filaPelicula.getFamilyMap(Bytes.toBytes("info"));
               resultado.add(new Pelicula(Bytes.toInt((byte[])mapInfo.get(Bytes.toBytes("id"))),
                                          Bytes.toString((byte[])mapInfo.get(Bytes.toBytes("titulo"))),
                                          new Date(Bytes.toLong((byte[])mapInfo.get(Bytes.toBytes("fechaEmision")))),
                                          Bytes.toLong((byte[])mapInfo.get(Bytes.toBytes("presupuesto"))),
                                          Bytes.toLong((byte[])mapInfo.get(Bytes.toBytes("ingresos"))),
                                          reparto, personal
                                         )
                             );
            }
            } finally {
                rs.close();  // always close the ResultScanner!
            }
            
        } catch (IOException | ClassNotFoundException ex) {
            System.out.print("Error al consultar la tabla de películas en HBase: "+ex.getMessage()+"\n");
        }
        return resultado;
    }

    @Override
    public void insertaPelicula(Pelicula p) {
        try {
            Put put = new Put(Bytes.toBytes(p.getIdPelicula()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("id"), Bytes.toBytes(p.getIdPelicula()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("titulo"), Bytes.toBytes(p.getTitulo()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("fechaEmision"), Bytes.toBytes(p.getFechaEmsion().getTime()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("presupuesto"), Bytes.toBytes(p.getPresupuesto()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("ingresos"), Bytes.toBytes(p.getIngresos()));
            for(int i = 0;i<p.getTamanoReparto();i++){
                put.addColumn(Bytes.toBytes("reparto"), 
                              Bytes.toBytes(String.format("r%04d",p.getReparto(i).getOrden())), 
                              Utils.serialize(p.getReparto(i)));
            }
            for(int i = 0;i<p.getTamanoPersonal();i++){
                put.addColumn(Bytes.toBytes("personal"), 
                              Bytes.toBytes(String.format("p%04d",i)), 
                              Utils.serialize(p.getPersonal(i)));
            }
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));
            pelsTable.put(put);
        } catch (IOException ex) {
            System.out.print("Error al insertar la pelicula: "+ex.getMessage()+"\n");
        }
        
    }
   
    public Pelicula getpelicula_id(int id){
        Pelicula resultado = null;

        try {
            Scan scan = new Scan();
            
            scan.addFamily(Bytes.toBytes("info"));
            scan.addFamily(Bytes.toBytes("reparto"));
            scan.addFamily(Bytes.toBytes("personal"));
            
            // Añadimos el filtro
            SingleColumnValueFilter filter = new SingleColumnValueFilter(
                    Bytes.toBytes("info"),
                    Bytes.toBytes("id"),
                    CompareOperator.EQUAL,
                    Bytes.toBytes(id)
            );
            scan.setFilter(filter);  
            
            // Obtenemos la tabla en la que ejecutar la busqueda
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));

            try (ResultScanner rs = pelsTable.getScanner(scan)) {
                for (Result filaPelicula = rs.next(); filaPelicula != null; filaPelicula = rs.next()) {
                    NavigableMap mapReparto = filaPelicula.getFamilyMap(Bytes.toBytes("reparto"));
                    Reparto[] reparto = new Reparto[mapReparto.size()];

                    int i = 0;
                    for (Map.Entry<byte[], byte[]> elemReparto : (Set<Map.Entry>) mapReparto.entrySet()) {
                        reparto[i] = (Reparto) Utils.deserialize(elemReparto.getValue());
                        i++;
                    }

                    NavigableMap mapPersonal = filaPelicula.getFamilyMap(Bytes.toBytes("personal"));
                    Personal[] personal = new Personal[mapPersonal.size()];

                    i = 0;
                    for (Map.Entry<byte[], byte[]> elemPersonal : (Set<Map.Entry>) mapPersonal.entrySet()) {
                        personal[i] = (Personal) Utils.deserialize(elemPersonal.getValue());
                        i++;
                    }

                    NavigableMap mapInfo = filaPelicula.getFamilyMap(Bytes.toBytes("info"));
                    resultado = new Pelicula(
                            Bytes.toInt((byte[]) mapInfo.get(Bytes.toBytes("id"))),
                            Bytes.toString((byte[]) mapInfo.get(Bytes.toBytes("titulo"))),
                            new Date(Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("fechaEmision")))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("presupuesto"))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("ingresos"))),
                            reparto,
                            personal
                    );
                }
            }
        } catch (IOException | ClassNotFoundException ex) {
            System.out.print("Error al consultar la tabla de películas en HBase: " + ex.getMessage() + "\n");
        }
        return resultado;
    }

    public Pelicula getpelicula_nombre(String nombre) {
    Pelicula resultado = null;


        try {
            Scan scan = new Scan();
            
            scan.addFamily(Bytes.toBytes("info"));
            scan.addFamily(Bytes.toBytes("reparto"));
            scan.addFamily(Bytes.toBytes("personal"));
            
            // Añadimos el filtro
            SingleColumnValueFilter filter = new SingleColumnValueFilter(
                    Bytes.toBytes("info"),
                    Bytes.toBytes("titulo"),
                    CompareOperator.EQUAL,
                    Bytes.toBytes(nombre)
            );
            scan.setFilter(filter);  
            
            // Obtenemos la tabla en la que ejecutar la busqueda
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));

            try (ResultScanner rs = pelsTable.getScanner(scan)) {
                for (Result filaPelicula = rs.next(); filaPelicula != null; filaPelicula = rs.next()) {
                    NavigableMap mapReparto = filaPelicula.getFamilyMap(Bytes.toBytes("reparto"));
                    Reparto[] reparto = new Reparto[mapReparto.size()];

                    int i = 0;
                    for (Map.Entry<byte[], byte[]> elemReparto : (Set<Map.Entry>) mapReparto.entrySet()) {
                        reparto[i] = (Reparto) Utils.deserialize(elemReparto.getValue());
                        i++;
                    }

                    NavigableMap mapPersonal = filaPelicula.getFamilyMap(Bytes.toBytes("personal"));
                    Personal[] personal = new Personal[mapPersonal.size()];

                    i = 0;
                    for (Map.Entry<byte[], byte[]> elemPersonal : (Set<Map.Entry>) mapPersonal.entrySet()) {
                        personal[i] = (Personal) Utils.deserialize(elemPersonal.getValue());
                        i++;
                    }

                    NavigableMap mapInfo = filaPelicula.getFamilyMap(Bytes.toBytes("info"));
                    resultado = new Pelicula(
                            Bytes.toInt((byte[]) mapInfo.get(Bytes.toBytes("id"))),
                            Bytes.toString((byte[]) mapInfo.get(Bytes.toBytes("titulo"))),
                            new Date(Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("fechaEmision")))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("presupuesto"))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("ingresos"))),
                            reparto,
                            personal
                    );
                }
            }
        } catch (IOException | ClassNotFoundException ex) {
            System.out.print("Error al consultar la tabla de películas en HBase: " + ex.getMessage() + "\n");
        }
        return resultado;
    }

    @Override
    public List<Pelicula> getPeliculas_id(int i) {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }

    
    public Pelicula getPelicula_id(int id) {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }

    /**
     *
     * @param nombre
     * @return
     */
    public Pelicula getPelicula_nombre(String nombre) {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
        //throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }
}



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package gal.usc.etse.mbd.bdge.hbasetest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.CompareOperator;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Admin;
import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.ConnectionFactory;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.ResultScanner;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;
import org.apache.hadoop.hbase.util.Bytes;

/**
 *
 * @author alumnogreibd
 */
public class DAOPeliculasHBase implements DAOPeliculas {
    Connection con;
    
    public DAOPeliculasHBase(){
        try {
            Configuration conf = HBaseConfiguration.create();
            this.con = ConnectionFactory.createConnection(conf);
        } catch (IOException ex) {
            System.out.print("Error conectando con HBase: "+ex.getMessage()+"\n");
        }
    }
    
    public void close(){
        try {
            con.close();
        } catch (IOException ex) {
            System.out.print("Error cerrando conexión con HBase: "+ex.getMessage()+"\n");
        }
    }

    @Override
    public List<Pelicula> getPeliculas(int num) {
        List<Pelicula> resultado = new ArrayList<Pelicula>();
        try {
            Scan scan = new Scan();
            scan.addFamily(Bytes.toBytes("info"));
            scan.addFamily(Bytes.toBytes("reparto"));
            scan.addFamily(Bytes.toBytes("personal"));
            scan.setLimit(num);
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));
            ResultScanner rs = pelsTable.getScanner(scan);
            try {
            for (Result filaPelicula = rs.next(); filaPelicula != null; filaPelicula = rs.next()) {
               NavigableMap mapReparto=filaPelicula.getFamilyMap(Bytes.toBytes("reparto"));
               Reparto[] reparto = new Reparto[mapReparto.size()];
               int i=0;
               for (Map.Entry<byte[], byte[]> elemReparto: (Set<Map.Entry>) mapReparto.entrySet()){
                 reparto[i]=(Reparto) Utils.deserialize(elemReparto.getValue());
                 i++;
               }
               NavigableMap mapPersonal=filaPelicula.getFamilyMap(Bytes.toBytes("personal"));
               Personal[] personal = new Personal[mapPersonal.size()];
               i=0;
               for (Map.Entry<byte[], byte[]> elemPersonal: (Set<Map.Entry>) mapPersonal.entrySet()){
                 personal[i]=(Personal) Utils.deserialize(elemPersonal.getValue());
                 i++;
               }
               NavigableMap mapInfo = filaPelicula.getFamilyMap(Bytes.toBytes("info"));
               resultado.add(new Pelicula(Bytes.toInt((byte[])mapInfo.get(Bytes.toBytes("id"))),
                                          Bytes.toString((byte[])mapInfo.get(Bytes.toBytes("titulo"))),
                                          new Date(Bytes.toLong((byte[])mapInfo.get(Bytes.toBytes("fechaEmision")))),
                                          Bytes.toLong((byte[])mapInfo.get(Bytes.toBytes("presupuesto"))),
                                          Bytes.toLong((byte[])mapInfo.get(Bytes.toBytes("ingresos"))),
                                          reparto, personal
                                         )
                             );
            }
            } finally {
                rs.close();  // always close the ResultScanner!
            }
            
        } catch (IOException | ClassNotFoundException ex) {
            System.out.print("Error al consultar la tabla de películas en HBase: "+ex.getMessage()+"\n");
        }
        return resultado;
    }

    @Override
    public void insertaPelicula(Pelicula p) {
        try {
            Put put = new Put(Bytes.toBytes(p.getIdPelicula()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("id"), Bytes.toBytes(p.getIdPelicula()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("titulo"), Bytes.toBytes(p.getTitulo()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("fechaEmision"), Bytes.toBytes(p.getFechaEmsion().getTime()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("presupuesto"), Bytes.toBytes(p.getPresupuesto()));
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("ingresos"), Bytes.toBytes(p.getIngresos()));
            for(int i = 0;i<p.getTamanoReparto();i++){
                put.addColumn(Bytes.toBytes("reparto"), 
                              Bytes.toBytes(String.format("r%04d",p.getReparto(i).getOrden())), 
                              Utils.serialize(p.getReparto(i)));
            }
            for(int i = 0;i<p.getTamanoPersonal();i++){
                put.addColumn(Bytes.toBytes("personal"), 
                              Bytes.toBytes(String.format("p%04d",i)), 
                              Utils.serialize(p.getPersonal(i)));
            }
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));
            pelsTable.put(put);
        } catch (IOException ex) {
            System.out.print("Error al insertar la pelicula: "+ex.getMessage()+"\n");
        }
        
    }
   
    public Pelicula getpelicula_id(int id){
        Pelicula resultado = null;

        try {
            Scan scan = new Scan();
            
            scan.addFamily(Bytes.toBytes("info"));
            scan.addFamily(Bytes.toBytes("reparto"));
            scan.addFamily(Bytes.toBytes("personal"));
            
            // Añadimos el filtro
            SingleColumnValueFilter filter = new SingleColumnValueFilter(
                    Bytes.toBytes("info"),
                    Bytes.toBytes("id"),
                    CompareOperator.EQUAL,
                    Bytes.toBytes(id)
            );
            scan.setFilter(filter);  
            
            // Obtenemos la tabla en la que ejecutar la busqueda
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));

            try (ResultScanner rs = pelsTable.getScanner(scan)) {
                for (Result filaPelicula = rs.next(); filaPelicula != null; filaPelicula = rs.next()) {
                    NavigableMap mapReparto = filaPelicula.getFamilyMap(Bytes.toBytes("reparto"));
                    Reparto[] reparto = new Reparto[mapReparto.size()];

                    int i = 0;
                    for (Map.Entry<byte[], byte[]> elemReparto : (Set<Map.Entry>) mapReparto.entrySet()) {
                        reparto[i] = (Reparto) Utils.deserialize(elemReparto.getValue());
                        i++;
                    }

                    NavigableMap mapPersonal = filaPelicula.getFamilyMap(Bytes.toBytes("personal"));
                    Personal[] personal = new Personal[mapPersonal.size()];

                    i = 0;
                    for (Map.Entry<byte[], byte[]> elemPersonal : (Set<Map.Entry>) mapPersonal.entrySet()) {
                        personal[i] = (Personal) Utils.deserialize(elemPersonal.getValue());
                        i++;
                    }

                    NavigableMap mapInfo = filaPelicula.getFamilyMap(Bytes.toBytes("info"));
                    resultado = new Pelicula(
                            Bytes.toInt((byte[]) mapInfo.get(Bytes.toBytes("id"))),
                            Bytes.toString((byte[]) mapInfo.get(Bytes.toBytes("titulo"))),
                            new Date(Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("fechaEmision")))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("presupuesto"))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("ingresos"))),
                            reparto,
                            personal
                    );
                }
            }
        } catch (IOException | ClassNotFoundException ex) {
            System.out.print("Error al consultar la tabla de películas en HBase: " + ex.getMessage() + "\n");
        }
        return resultado;
    }

    public Pelicula getpelicula_nombre(String nombre){
        Pelicula resultado = null;

        try {
            Scan scan = new Scan();
            
            scan.addFamily(Bytes.toBytes("info"));
            scan.addFamily(Bytes.toBytes("reparto"));
            
            // Añadimos el filtro
            SingleColumnValueFilter filter = new SingleColumnValueFilter(
                    Bytes.toBytes("info"),
                    Bytes.toBytes("title"),
                    CompareOperator.EQUAL,
                    Bytes.toBytes(nombre)
            );
            scan.setFilter(filter);  
            
            // Obtenemos la tabla en la que ejecutar la busqueda
            Table pelsTable = con.getTable(TableName.valueOf("peliculas"));

            try (ResultScanner rs = pelsTable.getScanner(scan)) {
                for (Result filaPelicula = rs.next(); filaPelicula != null; filaPelicula = rs.next()) {
                    NavigableMap mapReparto = filaPelicula.getFamilyMap(Bytes.toBytes("reparto"));
                    Reparto[] reparto = new Reparto[mapReparto.size()];

                    int i = 0;
                    for (Map.Entry<byte[], byte[]> elemReparto : (Set<Map.Entry>) mapReparto.entrySet()) {
                        reparto[i] = (Reparto) Utils.deserialize(elemReparto.getValue());
                        i++;
                    }


                    NavigableMap mapInfo = filaPelicula.getFamilyMap(Bytes.toBytes("info"));
                    resultado = new Pelicula(
                            Bytes.toInt((byte[]) mapInfo.get(Bytes.toBytes("id"))),
                            Bytes.toString((byte[]) mapInfo.get(Bytes.toBytes("titulo"))), (java.sql.Date) new Date(Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("fechaEmision")))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("presupuesto"))),
                            Bytes.toLong((byte[]) mapInfo.get(Bytes.toBytes("ingresos"))),
                            reparto,
                            null
                    );
                }
            }
        } catch (IOException | ClassNotFoundException ex) {
            System.out.print("Error al consultar la tabla de películas en HBase: " + ex.getMessage() + "\n");
        }
        return resultado;
    }

    @Override
    public List<Pelicula> getPeliculas_id(int i) {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }

    
    public Pelicula getPelicula_id(int id) {
        // Implementación del método getPelicula_id
        // Tu código para buscar la película por ID en HBase va aquí
        // Por ejemplo, puedes usar un objeto Get con el ID y obtener los detalles de la película
        // Asegúrate de cerrar los recursos como conexiones y tablas
        return null; // Retorna un objeto Pelicula o null si no se encuentra
    }

    @Override
    public Pelicula getPelicula_nombre(String nombre) {
        // Implementación del método getPelicula_nombre
        // Tu código para buscar la película por nombre en HBase va aquí
        // Por ejemplo, puedes usar un Scan con un filtro por el nombre y obtener los detalles
        // Asegúrate de cerrar los recursos como conexiones y tablas
        return null; // Retorna un objeto Pelicula o null si no se encuentra
    }
}